using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TFramework.Singleton;

namespace SoftLiu_ServerIOCSharp.Algorithm
{
    public class AlgorithmManager : AutoGeneratedSingleton<AlgorithmManager>
    { 
        public AlgorithmManager()
        {

        }

        public void Init()
        {
            //int n = 6;
            //int m = 2;
            //int result = IntegerPartition(n, m);
            //Console.WriteLine(string.Format("IntegerPartition n= {0} , m= {1} , result= {2}", n, m, result));

            //int n = 3;
            //int result = 0;
            //HanoiTower(n, 'A', 'B', 'C', ref result);
            //Console.WriteLine(string.Format("HanoiTower result= {0}", result));

            ChessBoard(10,0, 0, 0, 8);
            Console.WriteLine(title);
            Console.WriteLine();
        }
        private int title = 0;
        /// <summary>
        /// 棋盘覆盖
        /// </summary>
        /// <param name="tr">棋盘左上角方格的行号</param>
        /// <param name="tc">棋盘左上角方格的列号</param>
        /// <param name="dr">特殊方格所在的行号</param>
        /// <param name="dc">特殊方格所在的列号</param>
        /// 
        /// <param name="size">2的k次幂</param>
        public void ChessBoard(int tr, int tc, int dr, int dc, int size)
        {
            if (size <= 1) return;
            int t = title++;
            int s = size / 2;
            //左上角
            if (dr < tr + s && dc < tc + s)
            {
                ChessBoard(tr, tc, dr, dc, s);
            }
            else
            {
                ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s);
            }
            //右上角
            if (dr < tr + s && dc < tc + s)
            {
                ChessBoard(tr, tc + s, dr, dc, s);
            }
            else
            {
                ChessBoard(tr, tc + s, tr + s - 1, tc + s, s);
            }
            //左下
            if (dr < tr + s && dc < tc + s)
            {
                ChessBoard(tr + s, tc, dr, dc, s);
            }
            else
            {
                ChessBoard(tr + s, tc, tr + s, tc + s - 1, s);
            }

            // 右下
            if (dr < tr + s && dc < tc + s)
            {
                ChessBoard(tr + s, tc + s, dr, dc, s);
            }
            else
            {
                ChessBoard(tr + s, tc + s, tr + s, tc + s, s);
            }
        }

        /// <summary>
        /// Hanoi塔的问题
        /// </summary>
        /// <param name="n">一共需要移动的圆盘个数</param>
        /// <param name="A">塔编号：A</param>
        /// <param name="B">塔编号：B</param>
        /// <param name="C">他编号：C</param>
        /// <param name="result">步数</param>
        public void HanoiTower(int n, char A, char B, char C, ref int result)
        {
            if (n > 0)
            {
                HanoiTower(n - 1, A, C, B, ref result);
                result++;
                // move n from A to C
                Console.WriteLine(string.Format("第{0}步， {1} 从{2}到{3}", result, n, A, C));
                HanoiTower(n - 1, B, A, C, ref result);
            }
        }

        /// <summary>
        /// 整数划分问题
        /// </summary>
        /// <param name="n">要划分的整数</param>
        /// <param name="m">使用小于等于m的整数划分</param>
        /// <returns></returns>
        public int IntegerPartition(int n, int m)
        {
            if (n < 1 || m < 1) return 0;
            if (n == 1 || n == 1) return 1;
            if (m > n) return IntegerPartition(n, n);
            if (m == n) return (IntegerPartition(n, n - 1) + 1);
            return (IntegerPartition(n, m - 1) + IntegerPartition(n - m, m));
        }

        public void Dispose()
        {

        }
    }
}
